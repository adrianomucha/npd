layout: true
name: extend-classes

# Extending Classes

---

## An Overview of New Style Classes

  * All classes ultimately inherit from the `object` type:

```python
class MyClass(object):
  pass
```

  * In Python 3.0, this is assumed, thus the following is equivalent:

```python
class MyClass:
  pass
```

  * However, this is not the case for Python 2.x.
    * It is recommended that the explicit definition is always used for compatbility and consistency.

---

layout: true
template: extend-classes
name: difference-extend-classes

## Old Style Verus New Style

  * Remember, this only applies to Python 2.x.

  * In old style classes, all instances have the same type, `instance`.

  * With new style classes, the instance's type is it's class.

---

```python
class OldStyleClass:
  pass

class AnotherOldStyleClass:
  pass

class NewStyleClass(object):
  pass

class AnotherNewStyleClass(object):
  pass

print 'type of OldStyleClass instance: %r' % type(OldStyleClass())
print 'type of AnotherOldStyleClass instance: %r' % type(AnotherOldStyleClass())
print 'type of NewStyleClass instance: %r' % type(NewStyleClass())
print 'type of AnotherNewStyleClass instance: %r' % type(AnotherNewStyleClass())
```

---

```python
>>> type of OldStyleClass instance: <type 'instance'>
>>> type of AnotherOldStyleClass instance: <type 'instance'>
>>> type of NewStyleClass instance: <class '__main__.NewStyleClass'>
>>> type of AnotherNewStyleClass instance: <class '__main__.AnotherNewStyleClass'>
```

---

template: difference-extend-classes

  * Why do we prefer new style classes?
    * New style classes have improved support for multiple inheritance.

---

template: extend-classes

## Method Inheritance

  * When a class extends another class, it obtains the parent class's methods.

```python
class Parent(object):

  def my_method(self):
    print 'I am method in Parent'

class Child(Parent):

  pass

instance = Child()

instance.my_method()
```

--

```python
>>> I am method in Parent
```

---

layout: true
template: extend-classes
name: overriding-methods

## Overriding Methods

---

  * A child class can override a method defined the parent's class.

```python
class Parent(object):

  def my_method(self):
    print 'I am method in Parent'

class Child(Parent):

  def my_method(self):
    print 'I am method in Child'

instance = Child()

instance.my_method()
```

--

```python
>>> I am method in Child
```

---

  * A child class can explicitly call the method it overrides.

```python
class Parent(object):

  def my_method(self):
    print 'I am method in Parent'

class Child(Parent):

  def my_method(self):
    #Call overriden method in parent
    super(Child, self).my_method()
    print 'I am method in Child'

instance = Child()

instance.my_method()
```

--

```python
>>> I am method in Parent
>>> I am method in Child
```

---

  * This is commonly used when an extended instance needs to initialize it's parent as well.

```python
class Parent(object):

  def __init__(self):
    print 'Parent is initialized'

class Child(Parent):

  def __init__(self):
    super(Child, self).__init__()
    print 'Child is initialized'

instance = Child()
```

--

```python
>>> Parent is initialized
>>> Child is initialized
```

---

layout: true
template: extend-classes
name: multiple-inheritance

## Multiple Inheritance

  * A class can inherit (extend) from multiple classes.
  * A class that is inherited from multiple classes has access to methods implemented within each parent class.

---

```python
class Parent(object):

  def my_method(self):
    print 'I am method in Parent'

class AnotherParent(object):

  def another_method(self):
    print 'I am another method in a new parent class'

class Child(Parent, AnotherParent):

  def my_method(self):
    #Call overriden method in parent
    super(Child, self).my_method()
    print 'I am method in Child'

instance = Child()

instance.my_method()

instance.another_method()
```

---

```python
>>> I am method in Parent
>>> I am method in Child
>>> I am another method in a new parent class
```

---

layout: true
template: extend-classes
name: multiple-problems

## Multiple Inheritance: The Diamond Problem

---

  * Multiple inheritance can generate ambiguities as to how something is inherited.
  * Consider the following.

```python
class Parent(object):

  def my_method(self):
    print 'I am method in Parent'

class AnotherParent(object):

  def my_method(self):
    print 'I am another method in a new parent class'

class Child(Parent, AnotherParent):

  def my_method(self):
    #Call overriden method in parent
    #But which parent?
    super(Child, self).my_method()
    print 'I am method in Child'

instance = Child()

instance.my_method()
```

---

layout: true
template: multiple-problems

  * This is why the `super` function was implemented for new style classes.
  * What is returned by `super`?

---

```python
class MyClass(object):
  pass

class MyChildClass(MyClass):
  pass

print 'super returns: %r' % super(MyChildClass, MyChildClass())

print 'type of super returned: %r' % type(super(MyChildClass, MyChildClass()))
```

--

```python
>>> super returns: <super: <class 'MyChildClass'>, <MyChildClass object>>
>>> type of super returned: <type 'super'>
```

---

    * The `super` function returns a proxy object to resolve issues related to multiple inheritance.
    * When an attribute is accessed from the proxy object, it follows a Method Resolution Order (MRO) to determine which parent to resolve from.
      * N.B.: Python uses C3 Linearization to determine the MRO.

---

layout: true
template: multiple-problems

Let's revisit our provious example:

---

```python
class Parent(object):

  def my_method(self):
    print 'I am method in Parent'

class AnotherParent(object):

  def my_method(self):
    print 'I am another method in a new parent class'

class Child(Parent, AnotherParent):

  def my_method(self):
    #Call overriden method in parent
    #But which parent?
    super(Child, self).my_method()
    print 'I am method in Child'

instance = Child()

instance.my_method()
```

---

```python
>>> I am method in Parent
>>> I am method in Child
```

---

layout: true
template: multiple-problems

  * How can we determine which method will be resolved by `super`?
    * Examine the object's MRO.

---

```python
from pprint import pprint

class Parent(object):

  def my_method(self):
    print 'I am method in Parent'

class AnotherParent(object):

  def my_method(self):
    print 'I am another method in a new parent class'

class Child(Parent, AnotherParent):

  def my_method(self):
    #Call overriden method in parent
    #But which parent?
    super(Child, self).my_method()
    print 'I am method in Child'

instance = Child()

print 'instance's MRO:'
pprint(type(instance).__mro__)
```

---

```python
>>> instance's MRO:
>>> (<class '__main__.Child'>,
>>>  <class '__main__.Parent'>,
>>>  <class '__main__.AnotherParent'>,
>>>  <type 'object'>)
```

--

  * How does the method `my_method` get resolved?
    * Python's new style classes follows this MRO order until it finds a method to resolve.
    * Note since we are explicitly calling `super` in `Child`'s `my_method`, the actual resolution order is:
      * `Parent`
      * `AnotherParent`

---

template: multiple-problems
name: mro-description

  * Python's MRO can be summed up as follows:
    * Try the first ancestor class.
      * Continue up the ancestor's hierarchy.
    * If a type can be found as a super type of a sibling, stop recursing the branch and try the successive ancestor class.
      * Use the order as defined in the class declaration, from left to right.

---

template: mro-description

  * From our previous example:
    * Python first tries the class `Parent`, then examines `Parent`'s ancestor, `object`.
      * Since `object` is also a super class of `AnotherParent`, recursion on class `Parent` stops.
    * Python then continues with the second ancestor of `Child`, which is `AnotherParent`.
    * Finally, the last class to resolve is the common ancestor, `object`.

---

layout: true
template: extend-classes
name: more-problems

## Multiple Inheritance: Ambigious Resolution

  * Python's `super` function does not like redundant inheritance.

---

```python
from pprint import pprint

class Root(object):
  pass

class Parent(Root):
  pass

class AnotherParent(object):
  pass

class Child(Root, Parent, AnotherParent):
  pass

instance = Child()

print 'instance's MRO:'
pprint(type(instance).__mro__)
```

---

```python
>>> Traceback (most recent call last):
>>>   File "python/c03/s03/ex10.py", line 12, in <module>
>>>     class Child(Root, Parent, AnotherParent):
>>> TypeError: Error when calling the metaclass bases
>>>     Cannot create a consistent method resolution
>>> order (MRO) for bases AnotherParent, Root, Parent
```

--

  * Tip: Do not inherit from a class if inheriting from another class that is already a subclass.
    * In this case, there is no reason to define `Child` as inheriting from `Root` since `Parent` already inherits from it.

---

template: extend-classes

## Multiple Inheritance: Initialization Problem

  * The `super` function only finds and returns the first attribute (method) in the resolution order.
    * What happens when multiple classes need to be initialized?

```python
from pprint import pprint

class Parent(object):

  def __init__(self):
    print 'Initializing Parent'

class AnotherParent(object):

  def __init__(self):
    print 'Initializing AnotherParent'

class Child(Parent, AnotherParent):

  def __init__(self):
    # Only one parent will get initialized!
    super(Child, self).__init__()
    print 'Initializing Child'

instance = Child()
```

--

```python
>>> Initializing Parent
>>> Initializing Child
```

---

layout: true
template: extend-classes
name: work-arounds

## Multiple Inheritance: Mix-In Strategy

---

  * A Mix-In class implement methods that can be included into any class to implement functionality into that class.
    * A Mix-In should not be part of any inheritance heirarchy.

--

```python
class MixIn(object):

  def mixInStuff(self):
    print 'I Implement mix-in stuff!'

class SecondMixIn(object):
  def secondMixInStuff(self):
    print 'I Implement second mix-in suff!'

class ThirdMixIn(object):
  def thirdMixInStuff(self):
    print 'I Implement third mix-in stuff!'

class A(MixIn, SecondMixIn):
  pass

class B(MixIn, ThirdMixIn):
  pass

class C(SecondMixIn, ThirdMixIn):
  pass
```

---

```python
from ex12_inc import A, B, C

a = A()
b = B()
c = C()

print 'object a:'
a.mixInStuff()
a.secondMixInStuff()
print 'object b:'
b.mixInStuff()
b.thirdMixInStuff()
print 'object c:'
c.secondMixInStuff()
c.thirdMixInStuff()
```

--

```python
>>> object a:
>>> I Implement mix-in stuff!
>>> I Implement second mix-in suff!
>>> object b:
>>> I Implement mix-in stuff!
>>> I Implement third mix-in stuff!
>>> object c:
>>> I Implement second mix-in suff!
>>> I Implement third mix-in stuff!
```

---

template: extend-classes

## Excercise

  * Create a Mix-In class that implements the ability to convert an inheriting class to JSON.
    * Mix-In should implement the method `to_json` that returns a json string of the object.
  * Apply this Mix-In class to your extended Python dictionary to enable your dictionary to return a JSON version of itself when the `to_json` method is called.
